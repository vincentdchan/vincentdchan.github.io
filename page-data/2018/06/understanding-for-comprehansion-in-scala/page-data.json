{"componentChunkName":"component---src-templates-blog-template-js","path":"/2018/06/understanding-for-comprehansion-in-scala","webpackCompilationHash":"2b44acb7bdd5fa57a332","result":{"data":{"markdownRemark":{"html":"<p>Scala 中的 for 表达式非常强大，用起来很简单顺手，但是理解起来可能需要一些背景知识。这个 for 从名字上看让我们觉得它很像命令式语言中的那种 for statement，但是其实 Scala 的 for 是非常函数式的，它跟命令式语言中的 for 语句根本不是一个东西，因为它根本不支持 break 和 continue 这些语句。</p>\n<p>官方文档提供的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> twentySomethings <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>user <span class=\"token keyword\">&lt;-</span> userBase <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">>=</span><span class=\"token number\">20</span> <span class=\"token operator\">&amp;&amp;</span> user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">yield</span> user<span class=\"token punctuation\">.</span>name  <span class=\"token comment\">// i.e. add this to a list</span></code></pre></div>\n<p>Scala 的 for 表达式倒是很像 Python 和 Haskell 里面的 list comprehension，其实这个 for 表达式基本上可以等同于 Haskell 的 list comprehension 加上 do annotation 了。然而 Haskell 里面 list comprehension 和 do 也是一个东西，所以基本等同于 for comprehension。</p>\n<p>在理解 for 之前，需要先了解 <code class=\"language-text\">map</code> 和 <code class=\"language-text\">flatMap</code>，这些概念在 Scala 和 Haskell 中很相似：</p>\n<h2>Map</h2>\n<p><code class=\"language-text\">map</code> 大多数人会用在 List 上面，但是更广义的概念上，map 可以用在任何带有 context 的类型上面，不仅限于 List：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// map 通过一个函数，可以把 A 元素的列表转换成列表 B 的\nmap(f: A =&gt; B): List[A] =&gt; List[B]</code></pre></div>\n<p>同理，map 不仅可以用在 <code class=\"language-text\">List</code> 上面，也可以用在类似 Option 和 Future 这样的类型上面。从直观意义上理解，map 同样可以把 <code class=\"language-text\">Option[A]</code> 转换成 <code class=\"language-text\">Option[B]</code>，把 <code class=\"language-text\">Future[A]</code> 转换成 <code class=\"language-text\">Future[B]</code>。</p>\n<p>在 Hasekll 里面，这种支持 map 操作的类型，叫做 Functor，Scala 里面似乎没有一个名字。</p>\n<h2>FlatMap</h2>\n<p><code class=\"language-text\">flatMap</code> 理解起来则稍微复杂一些，看一下 List 里面的 <code class=\"language-text\">flatMap</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> flatMap<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> T <span class=\"token keyword\">=></span> List<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这里面的 <code class=\"language-text\">f</code> 不再像 <code class=\"language-text\">map</code> 里面返回一个新的子类型，而是，返回一个带有 context 类型本身： <code class=\"language-text\">List[U]</code>。也就是说 f 函数返回的新类型是包含在 context 里面的。<strong>需要注意的是</strong>在这里，返回的结果并不是 List[List[U]]，而是仅仅是 <code class=\"language-text\">List[U]</code> 。通过 <code class=\"language-text\">flatMap</code> 这个名字中的 <code class=\"language-text\">flat</code> 我们也知道，最后的结果会是把每个 list 都拼接在一起，也就是所谓的拍平了。</p>\n<p>上面提到的是 List 的 flatMap，同样地，<code class=\"language-text\">Future</code> 类型同样也是支持 <code class=\"language-text\">flatMap</code> 的，它的的参数 <code class=\"language-text\">f</code> 类型我们应该也猜到了：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> flatMap<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> T <span class=\"token keyword\">=></span> Future<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span></code></pre></div>\n<p>通过 flatMap 我们就可以做很多事情了。这个时候假设我们有函数 <code class=\"language-text\">fetch1</code> 和 <code class=\"language-text\">fetch2</code> ，都是返回 <code class=\"language-text\">Future[Response]</code>，如果我们要先 fetch1 然后根据 1 的 response 来 fetch2 ，然后把 2 的结果打印出来，我们要怎么做呢：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// 写法一</span>\n<span class=\"token keyword\">val</span> resp2 <span class=\"token operator\">=</span> fetch1\n<span class=\"token punctuation\">.</span>flatMap <span class=\"token punctuation\">{</span> resp1 <span class=\"token keyword\">=></span>\n    <span class=\"token comment\">// do something</span>\n    fetch2<span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 通过 1 的结果来返回新的 Future</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span> resp2 <span class=\"token keyword\">=></span>\n    printf<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n    resp2<span class=\"token punctuation\">.</span>data\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然后回到开头，我们可以用 for comprehension 来完成这个事情：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// 写法二</span>\n<span class=\"token keyword\">val</span> resp2 <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n    resp1 <span class=\"token keyword\">&lt;-</span> fetch1<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    resp2 <span class=\"token keyword\">&lt;-</span> fetch2<span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n    printf<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">yield</span> resp2<span class=\"token punctuation\">.</span>data</code></pre></div>\n<p>其实实际上，Scala 会把上述代码翻译成与下面等价的样子：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// 写法三</span>\n<span class=\"token keyword\">val</span> resp2 <span class=\"token operator\">=</span> resp1\n<span class=\"token punctuation\">.</span>flatMap <span class=\"token punctuation\">{</span> resp1 <span class=\"token keyword\">=></span>\n    fetch2<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span>\n        printf<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n    \tresp2<span class=\"token punctuation\">.</span>data\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>只要你仔细观察，你就会发现，在这个例子里面，这三种写法的结果都是一样的，但是第一种写法有什么缺点呢，缺点就是在第二个 <code class=\"language-text\">flatMap</code> 里面，<code class=\"language-text\">resp1</code> 已经不在作用域里面了，这个时候如果你还想调用 resp1 已经不可能了，但是写法三是可以的：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// 写法三</span>\n<span class=\"token keyword\">val</span> resp2 <span class=\"token operator\">=</span> resp1\n<span class=\"token punctuation\">.</span>flatMap <span class=\"token punctuation\">{</span> resp1 <span class=\"token keyword\">=></span>\n    fetch2<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span>\n        printf<span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 在这里仍然可以调用 resp1，因为它还在作用域里面</span>\n        printf<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n    \tresp2<span class=\"token punctuation\">.</span>data\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样看起来就跟 Haskell 的 Monad 很接近了。</p>\n<h2>For 表达式的几种翻译方式</h2>\n<p>其实明白了 map 和 flatMap 之后，for 表达式很容易理解了。但是实现起来还要参考 <a href=\"https://docs.scala-lang.org/tutorials/FAQ/yield.html\">for 表达式的翻译方式</a>。</p>\n<h3>If</h3>\n<p>值得注意的是 if 语法：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>x <span class=\"token keyword\">&lt;-</span> c<span class=\"token punctuation\">;</span> <span class=\"token keyword\">if</span> cond<span class=\"token punctuation\">)</span> <span class=\"token keyword\">yield</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>会被翻译成：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\">c<span class=\"token punctuation\">.</span>withFilter<span class=\"token punctuation\">(</span>x <span class=\"token keyword\">=></span> cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>x <span class=\"token keyword\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>当然会有 fallback （如果不支持 withFilter）：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\">c<span class=\"token punctuation\">.</span>filter<span class=\"token punctuation\">(</span>x <span class=\"token keyword\">=></span> cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>x <span class=\"token keyword\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这时候再看文章开头的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> twentySomethings <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>user <span class=\"token keyword\">&lt;-</span> userBase <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">>=</span><span class=\"token number\">20</span> <span class=\"token operator\">&amp;&amp;</span> user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">yield</span> user<span class=\"token punctuation\">.</span>name  <span class=\"token comment\">// i.e. add this to a list</span></code></pre></div>\n<p>会被翻译成：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> twentySomethings <span class=\"token operator\">=</span> userBase\n<span class=\"token punctuation\">.</span>filter <span class=\"token punctuation\">{</span> user <span class=\"token keyword\">=></span>\n    user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">>=</span><span class=\"token number\">20</span> <span class=\"token operator\">&amp;&amp;</span> user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span> _<span class=\"token punctuation\">.</span>name <span class=\"token punctuation\">}</span></code></pre></div>\n<p>就很容易理解了</p>\n<h3>赋值语句</h3>\n<p><code class=\"language-text\">for</code> 表达式中同样支持赋值语句（这里说的是 <code class=\"language-text\">=</code> 不是 <code class=\"language-text\">&lt;-</code>），这在处理异步请求的时候非常常见：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> resp2 <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n    resp1 <span class=\"token keyword\">&lt;-</span> fetch1<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    data <span class=\"token operator\">=</span> doSomething<span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">)</span>\n    resp2 <span class=\"token keyword\">&lt;-</span> fetch2<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    printf<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">yield</span> resp2<span class=\"token punctuation\">.</span>data</code></pre></div>\n<p>注意，在 for comprehension 中写 <code class=\"language-text\">=</code> 赋值语句并不需要写 <code class=\"language-text\">var</code> 或者 <code class=\"language-text\">val</code> ，至于为什么，只要看它会被翻译成什么样子就能明白：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> resp2 <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n    resp1 <span class=\"token keyword\">&lt;-</span> fetch1<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    data <span class=\"token operator\">=</span> doSomething<span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">)</span>\n    resp2 <span class=\"token keyword\">&lt;-</span> fetch2<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    printf<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">yield</span> resp2<span class=\"token punctuation\">.</span>data\n\n<span class=\"token keyword\">var</span> resp2 <span class=\"token operator\">=</span> fetch1<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span> resp1 <span class=\"token keyword\">=></span>\n    <span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">,</span> doSomething<span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span>flatMap <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span>resp1<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span>\n    \tfetch2<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span> resp2 <span class=\"token keyword\">=></span>\n        printf<span class=\"token punctuation\">(</span>resp2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n        resp2<span class=\"token punctuation\">.</span>data\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>所以这个时候再写 <code class=\"language-text\">val</code> 和 <code class=\"language-text\">var</code> 已经没什么意义了</p>\n<h2>CPS 变换</h2>\n<p>其实 Scala 做的这个变换是一种 CPS(Continuation Passing Style) 变换，把一系列看上去想是赋值 <code class=\"language-text\">&lt;-</code> 的操作转换成 CPS 的形式，这有什么好处呢，通过这种变换，map 和 flatMap 的参数 f 就可以是一个纯（Pure）的函数，也就是说通过一系列纯函数的组合，可以实现像命令式编程里面的有状态的赋值操作，而这些操作是含有上下文（context）的。</p>\n<p>另一个好处是，像下面这种调用：</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\">c1<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>p1 <span class=\"token keyword\">=></span> p1<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>p2 <span class=\"token keyword\">=></span> p2<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>p3 <span class=\"token keyword\">=></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>其实是尾递归调用，编译器可以为此做很多优化，提高运行速度。</p>\n<h1>总结</h1>\n<p>for comprehension 其实是一个很甜很好用的语法糖，可以帮我们省下很多代码。我们当然可以选择继续用 <code class=\"language-text\">flatMap</code> 和 <code class=\"language-text\">map</code>，但是 for 就能用很简单的语言写出来。当然，简单的背后是有代价的，用 for 的过程中就需要使用者明白表达式最终会被怎样转换成相应的 <code class=\"language-text\">flatMap</code> 和 <code class=\"language-text\">map</code> 代码，这样才能让我们写出简洁的 for comprehension。</p>\n<p>这个时候，我真的很佩服 Scala 的设计，让整个语言各个部分的设计都非常容易和优雅地组合，设计得相当地精妙，同时我在其中也看到了一些 Haskell 的味道。</p>","frontmatter":{"date":"2018-06-10T02:58:33.000Z","path":null,"title":"理解 Scala 中的 for 表达式","permalink":"understanding-for-comprehansion-in-scala","headerImage":null,"tags":["scala","for comprehension","CPS"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"title":"理解 Scala 中的 for 表达式"}}}