{"componentChunkName":"component---src-templates-blog-template-js","path":"/2020/04/implement-a-extremely-fast-js-bundler","webpackCompilationHash":"2b44acb7bdd5fa57a332","result":{"data":{"markdownRemark":{"html":"<h1>背景</h1>\n<p>平时大家在开发 JS 项目的时候，可能已经离不开 webpack 等打包工具了。而 webpack 打包速度大概就是“能用“的水平。大概去年开始，我就开始在构想，如果能写一个极速的打包工具，功能未必需要很强，可能对小项目非常有用。去年我用 C++ 写完 parser 之后，便没什么动力写下去了。但是最近发现有这个想法的不止我一个，Figma 的 CTO 业余之际写了一个打包器 <a href=\"https://github.com/evanw/esbuild\">https://github.com/evanw/esbuild</a>，可以说完完全全实现了我想象中的需求，不过他是用 Go 语言实现的。我看到这个项目时心里一想，这不是我去年就想做的事吗，这 push 我赶紧把打包压缩部分完成。</p>\n<h1>代码</h1>\n<p>Github 地址：<a href=\"https://github.com/vincentdchan/jetpack.js\">https://github.com/vincentdchan/jetpack.js</a></p>\n<h1>优化思路</h1>\n<h2>并行 Parsing</h2>\n<p>毫无疑问，每一个 js 文件的 parsing 可以在不同线程完成，这就需要支持并行的语言。由于 parsing 的结果是 AST，所以需要可以共享内存的语言（排除通过 messeage parsing 实现多线程的语言）。满足以上两个要求的语言不多。 Evan 选择了 Go，我选择了 C++。</p>\n<h2>减少遍历次数</h2>\n<p>要想速度快，就要减少 AST 的遍历次数。最好就是只遍历一次来生成代码，在 Parsing 构建 AST 的时候就收集足够的信息。但是这也意味着只能做比较浅层次的优化，不能做深层次的压缩（死代码消除，tree shaking 都做不了）。</p>\n<h2>架构</h2>\n<p>由上述思路我总结出了以下打包的架构：</p>\n<ol>\n<li>并行 parse 文件</li>\n<li>作用域提升、生成框架代码、重命名变量</li>\n<li>并行生成代码</li>\n<li>合并输出文件</li>\n</ol>\n<p>流程图如下：</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/daa0952c9a8d60b61578df2874246f63/048a3/Rocket-Bundle-Arch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 98.93162393162393%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAADLklEQVQ4y5VUS0iUURT+/99pxuyhzJSZGUIzlFZMqYEijK9FjyEoQ2oVJC1s06JgluIimoUQKWg4Qi1sJaPiW3AU1MX4GsHnKIMz6vgWx/C5kODvO5e59ms62IHDvefee757z/nOuYJwjPT19QmyLLP5wsLCm42NjS+BQOAT9Ovc3NxjWse+2NTUJJxKlIAA+LaysuJZWlpyrq6uen0+34cgoFRfX/+vc1JSkpCcnCzSGJwLarWa7dntdjbq9Xq11Wq9wX34Zdyf+4WUhoYGASEy5KGhoTy81NfW1maEKbndbhWFfNSHgQI9HBM9xiioymg0hufm5oYpD1ZUVGhKS0t1QRBJ+VJJkghDA4wz/MkRMG5ijMeoTU1NvYZllcfj0XZ2dlqdTudr2KJWq42g893d3ZHQlyMjI/fJbmlpoZfFQiNDhgzAvO3tbdnlctlgavLz82OCgI9Azq/FxcWf/GxGRkaYMuQDUmghJSXlALSwsPCCMsSgaAoKCs4dIZZCFg8SSapkand3V9DpdGze2toaXllZebuoqMhUW1sbb7FYNByorKyMY6jJ/1ipqanh9cfCQGgvwLY8Ozsrr6+vbyEVibSOVEhxcXEcUAvVKOuQaVZWFltrbm4W9/b22IG1tbXnmBOYvLOzszU9PZ0YZFhVXl4uBgEvQSNO1TUlJSUxVVVV94qLixPq6urums3mQ45UOgaDQVKSQgm9SrdkZ2dT4s47HI4H6OEfKI13dBDt9sTv93+H3rLZbFempqbsUEdjY2MC7ZtMpmj4n+UhR8K4Q8WdmZkZTzXY29v7EP3rRt4+0xn0sQW2f3l5+RH6/Dpy6kLp2EFWLO2np6cT4EXhlKIOZXd0dIiHWo8TQoqQ2UZ/f7/Ie7W9vf1yT0/Pq+rq6vfoaTOqgOVwc3NTQsjsTFpa2t/Pgf8WpKh4tra/vy8gX6xs5ufnnwJcxhqx/HtgYID9OqOjoyInBTkPHSPdNjY2xub4WXSTk5PPBgcH3wI8Bz8OS35XV5dwYjGfJCCFvXJmZiYHRARASDTZuEwS/lcmJiYIkIXl9XoNYPjj8PBwFNnj4+MC8nqs3x/sSaK0RZ34LgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Rocket Bundle Arch\"\n        title=\"\"\n        src=\"/static/daa0952c9a8d60b61578df2874246f63/84ad3/Rocket-Bundle-Arch.png\"\n        srcset=\"/static/daa0952c9a8d60b61578df2874246f63/687da/Rocket-Bundle-Arch.png 175w,\n/static/daa0952c9a8d60b61578df2874246f63/0ab4d/Rocket-Bundle-Arch.png 350w,\n/static/daa0952c9a8d60b61578df2874246f63/84ad3/Rocket-Bundle-Arch.png 700w,\n/static/daa0952c9a8d60b61578df2874246f63/ef8d3/Rocket-Bundle-Arch.png 1050w,\n/static/daa0952c9a8d60b61578df2874246f63/fed13/Rocket-Bundle-Arch.png 1400w,\n/static/daa0952c9a8d60b61578df2874246f63/048a3/Rocket-Bundle-Arch.png 1872w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n      />\n  </span>\n  </a></p>\n<h1>打包压缩原理</h1>\n<p>本章节主要讲如何“最简单“地压缩 Js 代码。本章节假设读者对编译原理有一定了解，知道什么是 AST。如果不懂请直接跳到下文「性能」章节。</p>\n<h2>字面量替换</h2>\n<p>字面替换最简单。规则有一下几个：</p>\n<ul>\n<li>undefined 替换为 <code class=\"language-text\">void 0</code></li>\n<li>true 替换为 <code class=\"language-text\">!0</code>, false 替换为 <code class=\"language-text\">!1</code></li>\n</ul>\n<p>⚠️ 注意：在 ES 中，undefined 是标识符（Identifier)，而不是关键字，也就是说你可以定义一个叫 undefined 的变量，所以这个时候不能简单地替换为 <code class=\"language-text\">void 0</code></p>\n<h2>常量折叠</h2>\n<p>计算简单的运算：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> two <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> foobar <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span> <span class=\"token operator\">+</span> <span class=\"token string\">'bar'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>转换成</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> two <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> foobar <span class=\"token operator\">=</span> <span class=\"token string\">'foobar'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>⚠️ 注意：这里要注意实现的平台和 js 的差异，比如在 C++ 里面大整数相加可能会溢出，而在 Js 会自动转换成 bigint. 加法问题就如此，其他运算符问题更多。如果要完整实现常量折叠，可能要部分实现 js 引擎。</p>\n<h2>变量别名</h2>\n<p>别名就是要给变量重新赋予比较短的变量名。从字母一直排上去，abcd，一个字母用完了用两个字母。实现起来也很简单，用一个计数器，一直加上去就可。最后每个变量分配一个数字，把这个数字映射到相应的英文字母上，有点像 36 进制转换成字母的面试题。不过这里有一点值得注意的是，变量名第一个字母不能是数字，第二个字母开始可以是数字，要考虑到这一点，才能尽可能“压榨”变量名。</p>\n<p>为了尽可能地“压榨”变量名，同一级的作用域里面的变量名是可以使用相同的变量名。到下一级的时候，对子作用域进行合并。</p>\n<p>举个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Mother</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">var</span> e <span class=\"token operator\">=</span> <span class=\"token string\">'capture'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// d 不能使用跟子作用域同样的变量名，不然子作用域无法捕获这个变量</span>\n\t<span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token keyword\">function</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">// B 跟 A 函数同级，分配同样的变量名</span>\n\t  <span class=\"token comment\">// ...</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上述例子中，A 和 B 都没有子作用域了，变量名从 0 开始分配。到给 Mother 下 e 分配变量名时，找到子作用域最大的计数器。分配最多的子作用域 A 分配了 4 个，所以 B 计数器从 5 开始分配，所以给 e 分配了5，所以 e 就得到了这个名字。</p>\n<p>所以变量别名就是从 AST 的叶子开始向上构造，一直分配到根结点把所有作用域都分配完为止。</p>\n<p><strong>小技巧</strong></p>\n<p>这里 esbuild 采用了比较聪明的技巧。它统计了所有变量的引用次数，然后进行排序，引用次数最多的变量分配到的名字就是尽量短的，这样也可以减少编译出来 js 的体积。我在写 jetpack 打包的时候，也借鉴了这种做法。</p>\n<h2>模块合并</h2>\n<p>模块合并的办法有很多。webpack 采用的是用 function 把每个函数包起来，放到了一个长长的数组里面，然后实现了自己的 require，esbuild 也采用了类似的方法。</p>\n<p>Rollup.js 实现的方法则是作用域提升（Scope hoisting），把模块都放到根作用域。这里我采用的方法也是作用域提升。</p>\n<p>假设有 a.js 文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然后有 main.js 文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token constant\">A</span> <span class=\"token keyword\">as</span> ExternalA <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./a'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'local A'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">ExternalA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>使用 jetpack 打包完的结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// a.js</span>\n<span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// main.js</span>\n<span class=\"token keyword\">function</span> <span class=\"token constant\">A_0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'local A'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A_0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> main <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>难点在于作用域合并。实际上在 ES modules 里面不同 modules 之间引用是一个图结构。</p>\n<h1>C++ 的优化</h1>\n<p>除了策略上的优化，C++ 还提供了诸多基础数据结构/内存方面的优化。</p>\n<h2>shared_ptr</h2>\n<p>AST 的结点全部使用 shared_ptr，有人可能认为这是一个很大的开销。但是早期的时候我实现过一个裸指针版本（不释放内存），并没有测出有明显差距。</p>\n<p>使用 shared<em>ptr 很重要一个原因是，一个子树可能被其他类拥有（打包模块，Scope，ES Module 管理器）。这个时候如果用 unique</em>ptr 的话就会 gg。只能说 GC 大法好。</p>\n<p>对于 C++ 这种没有 GC 的语言有一个毛病就是：析构 AST 非常耗时。AST 够大的话能耗上十几 ms（这个时间跟 gc 比有何优势？），所以因此我也能想出了一个办法：<strong>不释放内存</strong>……。</p>\n<p>最后说一句：<strong>GC 大法好</strong>。</p>\n<h2>robin hood hashing</h2>\n<p>由于打包器中大量使用哈希表，所以提高哈希表速度尤其重要，这里我使用了 robin hood hashing</p>\n<p>参见：<a href=\"https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/\">https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/</a></p>\n<p>在 hash 方面我有一个设想，就是像 Lua 一样，对于短字符，在字符串创建的时候把 hash 记下来，这样在多次使用哈希表的时候可以节省 hash 的时间（但是要求字符串是 immutable 的）。为此我专门写了个 String 类，最后的结果是总体速度慢了 2-3x，测出来是 immutable 字符串拼接耗时太多，最后放弃了这个方案。</p>\n<h2>jemalloc</h2>\n<p>Parsing 过程中需要大量分配 node，大家都知道很明显 C++ 的 new 并不够快。经过测试在 macOS 下使用 jemalloc 会让 parsing 速度提升 1 倍。使<strong>用系统 malloc 会导致 parsing 速度比 Go 慢 1x 左右，慢在 new</strong>。</p>\n<p>当然了，内存池我也试过的，测出来速度基本和 jemalloc 一样，所以就直接用 jemalloc 了。</p>\n<h1>性能</h1>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4a0bbc222354481a55461d78be203165/edc9a/chart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 600px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 61.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABm0lEQVQoz41TPS8EQRi+vyORaAjxWRE/RCcRDVH4VqDWyCEiSjWRnEOlIggKzWlEiNzt3u7e3szOx2PemVu3IXdM8uR5P3aemTz7Tk5rDVqMMSilbEyc1onTerteGueU6+H8IcZEPsL0YR1TB3FbTO7HeH6TJAMhfwgGYQ1x9QOHlz46Z6sYWA7Rt9gCS45H1kLcvEgr9EuQJ8KkHEdXIfqXAoxvRhhbb41R4o2oIajBEgXSVKlg6k1QYygHEn6sUQklvEjBr2nLlFNMqETSoOkpiaYsnYeuUHpnOLllKD4JFB4SnBEeheVCGj82e6f3Aid3idnDcXyb4DOgQ4ygkCRYNx566JqrYng1sj7+hcGVEEMrjsnT65JoCsq6h73CJzpmAvQa03vm/4mFEN3zTvRbUDXm5v6ljq3TGLsXHPkiw845t8hbZHNma9l8u8jxWlbWxxz9brJRS2ZPaIxvxmxaskWsM3vMTArhBN1L4eBCgS4cRrEFdRgXKHu+HQ1hmuWKD55I26MZJmg7j2YyPK8p6G7aOtbZuM13X4vyUmlB7fTqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"chart\"\n        title=\"\"\n        src=\"/static/4a0bbc222354481a55461d78be203165/edc9a/chart.png\"\n        srcset=\"/static/4a0bbc222354481a55461d78be203165/29bfd/chart.png 175w,\n/static/4a0bbc222354481a55461d78be203165/ba183/chart.png 350w,\n/static/4a0bbc222354481a55461d78be203165/edc9a/chart.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n      />\n  </span>\n  </a></p>\n<h1>总结</h1>\n<p>写编译器需要快速大量产生 node 结点，大量树和图的结构，这一方面的运算 C++ 并没有什么优势可言。</p>\n<p>不得不承认，使用 C++ 你要思考很多东西，做很多很多额外的工作，才能获得比 Go 还快的速度（什么都不想做出来只会比 Go 还慢）。另一方面使用 C++ 会让你额外考虑很多和业务无关的东西，大大降低开发速度，而对于打包器这个场景 C++ 在这一块本身不能提供很大优势。</p>","frontmatter":{"date":"2020-04-25T17:35:00.000Z","path":"/2020/04/implement-a-extremely-fast-js-bundler","title":"写一个飞快的 Js 打包压缩工具","permalink":null,"headerImage":null,"tags":["C++","javascript","bundler","ecmascript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"title":"写一个飞快的 Js 打包压缩工具"}}}