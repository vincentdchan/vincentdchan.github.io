{"componentChunkName":"component---src-templates-blog-template-js","path":"/2020/01/using-sqlite-with-multi-threads-cpp","webpackCompilationHash":"cca743773e3a2b2c28a4","result":{"data":{"markdownRemark":{"html":"<p>因为工作的原因使用 SQLite 作为本地数据库，然而 SQLite 和 C++ 配合使用有许许多多的坑，此文用于记录工作过程中使用 SQLite 的坑。</p>\n<h2>Last Insert rowId</h2>\n<p><a href=\"https://www.notion.so/SQLite-with-C-db4c079d709c452dbee7fc41844766d4#24c415960ef841babe1639f7b826fe10\">Last Insert Rowid</a></p>\n<p>SQLite 中有一个函数可以获得最最近 insert 的一行的 id。也就是说，当你 insert 新的自增的一行时，你可以用 <code class=\"language-text\">sqlite3_last_insert_rowid()</code> 这个函数拿到这一行的 ID 这是一个取巧的办法，实际上这个函数是记录在 sqlite 实例里面的一个变量。这个变量的读写当然是没问题的，但是它需要和上一次 step 串行执行并上锁。</p>\n<p>假设你有如下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">sqlite3_step</span><span class=\"token punctuation\">(</span>stmt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span><span class=\"token keyword\">int64_t</span> id <span class=\"token operator\">=</span> <span class=\"token function\">sqlite3_last_insert_rowid</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>你必须为这两句话上锁，因为如果这两句语句中间有其他线程插入了数据，你从 <code class=\"language-text\">sqlite3_last_insert_rowid</code> 拿到的是其他线程的数据。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">sqlite3_step</span><span class=\"token punctuation\">(</span>stmt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 其他线程也执行了 sqlite_step() 导致下面语句 rowid 不对</span>\nstd<span class=\"token operator\">::</span><span class=\"token keyword\">int64_t</span> id <span class=\"token operator\">=</span> <span class=\"token function\">sqlite3_last_insert_rowid</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>正确写法</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">{</span>\n  std<span class=\"token operator\">::</span>lock_guard<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">guard</span><span class=\"token punctuation\">(</span>mt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">sqlite3_step</span><span class=\"token punctuation\">(</span>stmt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  std<span class=\"token operator\">::</span><span class=\"token keyword\">int64_t</span> id <span class=\"token operator\">=</span> <span class=\"token function\">sqlite3_last_insert_rowid</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>附上 SQLite 获取 last_rowid 的源码：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/*\n** Return the ROWID of the most recent insert\n*/</span>\nsqlite_int64 <span class=\"token function\">sqlite3_last_insert_rowid</span><span class=\"token punctuation\">(</span>sqlite3 <span class=\"token operator\">*</span>db<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> db<span class=\"token operator\">-></span>lastRowid<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>事务</h2>\n<p>事务可以说是 SQLite 里面多线程使用最坑的东西了。SQLite 不像其他 C/S 数据库一样一条链接保持一个事务。它就是纯函数调用。</p>\n<h3>乱序提交</h3>\n<p>SQLite 本身可以保证 step 是线程安全的，也就是多个线程同时 step 是没问题的。但是会有乱序提交的问题。比如一个线程开启事务进行提交，另一个线程也同时进行提交，这个线程回滚导致了其他线程的提交也回滚了。</p>\n<p>所以事务提交要上锁，主动上锁的话，一来性能下去了不说，二来忘了上锁就 gg，这个地方很坑。</p>\n<h3>多实例</h3>\n<p>既然 SQLite 是一个实例一个事务，那么每一个事务我开一个 SQLite 实例是不是就可以了呢。答案是依然有坑。</p>\n<p>一个 DEFERRED 的事务（SQLite 事务默认是 DEFFERED）如果执行了一句写的语句，就会锁住整个数据库，直到 COMMIT，在写事务开始到结束之前，其他实例执行任何语句都会返回 SQLITE_BUSY（数据库繁忙）。不止 step 哦，是 prepare 也会哦，是不是很惊喜。如果你这个事务很长，其他实例也用不了数据库了（跟上锁也没啥区别）。</p>\n<p>峰回路转，我终于在 SQLite 的 API 里面找到了一个 <code class=\"language-text\">busy_handler</code>，可以在 busy 的时候执行一个回调函数，让你去做一些操作，比如重试。刚好官网也实现了一个实现了一个重试的 busy handler，你只要设置好 <code class=\"language-text\">busy_timeout</code> 这个参数就可以了，这个默认的 handler 就会贴心地帮你重试。而它的做法就是过一会儿再帮你提交一遍，直到 timeout 为止，显而易见这种做法非常挫，这挫做法导致它比用户自己加锁更慢。</p>\n<p>下面看一下 sqlite 的默认 busy handler 的源码：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/*\n** This routine implements a busy callback that sleeps and tries\n** again until a timeout value is reached.  The timeout value is\n** an integer number of milliseconds passed in as the first\n** argument.\n*/</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sqliteDefaultBusyCallback</span><span class=\"token punctuation\">(</span>\n <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span>               <span class=\"token comment\">/* Database connection */</span>\n <span class=\"token keyword\">int</span> count                <span class=\"token comment\">/* Number of times table has been busy */</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">if</span> SQLITE_OS_WIN || (defined(HAVE_USLEEP) &amp;&amp; HAVE_USLEEP)</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> u8 delays<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n     <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">25</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">50</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> u8 totals<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n     <span class=\"token punctuation\">{</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">18</span><span class=\"token punctuation\">,</span> <span class=\"token number\">33</span><span class=\"token punctuation\">,</span> <span class=\"token number\">53</span><span class=\"token punctuation\">,</span> <span class=\"token number\">78</span><span class=\"token punctuation\">,</span> <span class=\"token number\">103</span><span class=\"token punctuation\">,</span> <span class=\"token number\">128</span><span class=\"token punctuation\">,</span> <span class=\"token number\">178</span><span class=\"token punctuation\">,</span> <span class=\"token number\">228</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"># <span class=\"token directive keyword\">define</span> NDELAY (sizeof(delays)/sizeof(delays[0]))</span>\n  sqlite3 <span class=\"token operator\">*</span>db <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>sqlite3 <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> timeout <span class=\"token operator\">=</span> db<span class=\"token operator\">-></span>busyTimeout<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> delay<span class=\"token punctuation\">,</span> prior<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span> count<span class=\"token operator\">>=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> count <span class=\"token operator\">&lt;</span> NDELAY <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    delay <span class=\"token operator\">=</span> delays<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    prior <span class=\"token operator\">=</span> totals<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n    delay <span class=\"token operator\">=</span> delays<span class=\"token punctuation\">[</span>NDELAY<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    prior <span class=\"token operator\">=</span> totals<span class=\"token punctuation\">[</span>NDELAY<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> delay<span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>count<span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>NDELAY<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> prior <span class=\"token operator\">+</span> delay <span class=\"token operator\">></span> timeout <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    delay <span class=\"token operator\">=</span> timeout <span class=\"token operator\">-</span> prior<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> delay<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sqlite3OsSleep</span><span class=\"token punctuation\">(</span>db<span class=\"token operator\">-></span>pVfs<span class=\"token punctuation\">,</span> delay<span class=\"token operator\">*</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n  sqlite3 <span class=\"token operator\">*</span>db <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>sqlite3 <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> timeout <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sqlite3 <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>busyTimeout<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>count<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">1000</span> <span class=\"token operator\">></span> timeout <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sqlite3OsSleep</span><span class=\"token punctuation\">(</span>db<span class=\"token operator\">-></span>pVfs<span class=\"token punctuation\">,</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这是一段退避重试的代码。可知重试时间是毫秒级的。这个延时速度真的还不如自己上锁呢……</p>\n<h3>正确写法</h3>\n<p>所以这里建议在 C++ 里面使用事务，还是使用单实例 + 使用的时候上锁来解决。另外要保证只有一个线程使用了事务，而且这个线程使用事务的时候，其他线程不能提交。</p>\n<h2>总结</h2>\n<p>SQLite 是一个很古老的数据库 lib。在业界也被广为使用。但是它的一些 api 设计真的有点坑。鉴于 SQLite 古老的历史，也许这些 api 不易修改得对多线程友好。所以在使用的时候还是要多多注意。写到这里，我想到了 sqlite 官方 FAQ 的一句话：<a href=\"https://www.sqlite.org/faq.html\">https://www.sqlite.org/faq.html</a>。</p>\n<blockquote>\n<p>Threads are evil. Avoid them.</p>\n</blockquote>\n<p>同时还贴出了一篇论文：<a href=\"https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf\">https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf</a></p>\n<p>或许 SQLite 的作者真的不喜欢多线程，才设计成这个样子吧。</p>","frontmatter":{"date":"2020-01-13T23:55:00.000Z","path":"/2020/01/using-sqlite-with-multi-threads-cpp","title":"多线程 SQLite with C++ 踩坑汇总","permalink":null,"headerImage":null,"tags":["C++","SQLite","multi-threads","多线程"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"title":"多线程 SQLite with C++ 踩坑汇总"}}}