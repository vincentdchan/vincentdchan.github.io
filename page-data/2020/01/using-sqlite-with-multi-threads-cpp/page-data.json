{"componentChunkName":"component---src-templates-blog-template-js","path":"/2020/01/using-sqlite-with-multi-threads-cpp","webpackCompilationHash":"c1cd6ea6efab31ccb48d","result":{"data":{"markdownRemark":{"html":"<p>因为工作的原因使用 SQLite 作为本地数据库，然而 SQLite 和 C++ 配合使用有许许多多的坑，此文用于记录工作过程中使用 SQLite 的坑。</p>\n<h2>Last Insert rowId</h2>\n<p><a href=\"https://www.notion.so/SQLite-with-C-db4c079d709c452dbee7fc41844766d4#24c415960ef841babe1639f7b826fe10\">Last Insert Rowid</a></p>\n<p>SQLite 中有一个函数可以获得最最近 insert 的一行的 id。也就是说，当你 insert 新的自增的一行时，你可以用 <code>sqlite3_last_insert_rowid()</code> 这个函数拿到这一行的 ID 这是一个取巧的办法，实际上这个函数是记录在 sqlite 实例里面的一个变量。这个变量的读写当然是没问题的，但是它需要和上一次 step 串行执行并上锁。</p>\n<p>假设你有如下代码：</p>\n<pre><code class=\"language-cpp\">sqlite3_step(stmt);\nstd::int64_t id = sqlite3_last_insert_rowid(db);\n</code></pre>\n<p>你必须为这两句话上锁，因为如果这两句语句中间有其他线程插入了数据，你从 <code>sqlite3_last_insert_rowid</code> 拿到的是其他线程的数据。</p>\n<pre><code class=\"language-cpp\">sqlite3_step(stmt);\n// 其他线程也执行了 sqlite_step() 导致下面语句 rowid 不对\nstd::int64_t id = sqlite3_last_insert_rowid(db);\n</code></pre>\n<h3>正确写法</h3>\n<pre><code class=\"language-cpp\">{\n  std::lock_guard&#x3C;std::mutex> guard(mt);\n  sqlite3_step(stmt);\n  std::int64_t id = sqlite3_last_insert_rowid(db);\n}\n</code></pre>\n<p>附上 SQLite 获取 last_rowid 的源码：</p>\n<pre><code class=\"language-cpp\">/*\n** Return the ROWID of the most recent insert\n*/\nsqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){\n  return db->lastRowid;\n}\n</code></pre>\n<h2>事务</h2>\n<p>事务可以说是 SQLite 里面多线程使用最坑的东西了。SQLite 不像其他 C/S 数据库一样一条链接保持一个事务。它就是纯函数调用。</p>\n<h3>乱序提交</h3>\n<p>SQLite 本身可以保证 step 是线程安全的，也就是多个线程同时 step 是没问题的。但是会有乱序提交的问题。比如一个线程开启事务进行提交，另一个线程也同时进行提交，这个线程回滚导致了其他线程的提交也回滚了。</p>\n<p>所以事务提交要上锁，主动上锁的话，一来性能下去了不说，二来忘了上锁就 gg，这个地方很坑。</p>\n<h3>多实例</h3>\n<p>既然 SQLite 是一个实例一个事务，那么每一个事务我开一个 SQLite 实例是不是就可以了呢。答案是依然有坑。</p>\n<p>一个 DEFERRED 的时候如果执行了一句写的语句，就会锁住整个数据库，直到 COMMIT 之前，其他实例执行任何语句都会返回 SQLITE_BUSY。不止 step 哦，是 prepare 也会哦，是不是很惊喜。如果你这个事务很长，其他实例也是不用写了（跟上锁也没啥区别）。</p>\n<p>峰回路转，你终于找到了一个 busy<em>handler，可以在 busy 的时候执行一个回掉，刚好官网也实现了一个实现了一个重拾的 handler，你只要设置好 busy</em>timeout 就可以了，它就会贴心帮你重试。而它的做法就是过一会儿再帮你提交一遍，直到 timeout 为止，这挫做法导致它比自己加锁更慢。</p>\n<p>下面看一下 sqlite 的默认 busy handler 的源码：</p>\n<pre><code class=\"language-cpp\">/*\n** This routine implements a busy callback that sleeps and tries\n** again until a timeout value is reached.  The timeout value is\n** an integer number of milliseconds passed in as the first\n** argument.\n*/\nstatic int sqliteDefaultBusyCallback(\n void *ptr,               /* Database connection */\n int count                /* Number of times table has been busy */\n){\n#if SQLITE_OS_WIN || (defined(HAVE_USLEEP) &#x26;&#x26; HAVE_USLEEP)\n  static const u8 delays[] =\n     { 1, 2, 5, 10, 15, 20, 25, 25,  25,  50,  50, 100 };\n  static const u8 totals[] =\n     { 0, 1, 3,  8, 18, 33, 53, 78, 103, 128, 178, 228 };\n# define NDELAY (sizeof(delays)/sizeof(delays[0]))\n  sqlite3 *db = (sqlite3 *)ptr;\n  int timeout = db->busyTimeout;\n  int delay, prior;\n\n  assert( count>=0 );\n  if( count &#x3C; NDELAY ){\n    delay = delays[count];\n    prior = totals[count];\n  }else{\n    delay = delays[NDELAY-1];\n    prior = totals[NDELAY-1] + delay*(count-(NDELAY-1));\n  }\n  if( prior + delay > timeout ){\n    delay = timeout - prior;\n    if( delay&#x3C;=0 ) return 0;\n  }\n  sqlite3OsSleep(db->pVfs, delay*1000);\n  return 1;\n#else\n  sqlite3 *db = (sqlite3 *)ptr;\n  int timeout = ((sqlite3 *)ptr)->busyTimeout;\n  if( (count+1)*1000 > timeout ){\n    return 0;\n  }\n  sqlite3OsSleep(db->pVfs, 1000000);\n  return 1;\n#endif\n}\n</code></pre>\n<p>这是一段退避重试的代码。可知重试时间是毫秒级的。这个延时速度真的还不如自己上锁呢……</p>\n<h3>正确写法</h3>\n<p>所以这里建议在 C++ 里面使用事务，还是使用单实例 + 使用的时候上锁来解决。另外要保证只有一个线程使用了事务，而且这个线程使用事务的时候，其他线程不能提交。</p>\n<h2>总结</h2>\n<p>SQLite 是一个很古老的数据库 lib。在业界也被广为使用。但是它的一些 api 设计真的有点坑。鉴于 SQLite 古老的历史，也许这些 api 不易修改得对多线程友好。所以在使用的时候还是要多多注意。写到这里，我想到了 sqlite 官方 FAQ 的一句话：<a href=\"https://www.sqlite.org/faq.html\">https://www.sqlite.org/faq.html</a>。</p>\n<blockquote>\n<p>Threads are evil. Avoid them.</p>\n</blockquote>\n<p>同时还贴出了一篇论文：<a href=\"https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf\">https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf</a></p>\n<p>或许 SQLite 的作者真的不喜欢多线程，才设计成这个样子吧。</p>","frontmatter":{"date":"2020-01-13T23:55:00.000Z","path":"/2020/01/using-sqlite-with-multi-threads-cpp","title":"多线程 SQLite with C++ 踩坑汇总","permalink":null,"headerImage":null,"tags":["C++","SQLite","multi-threads","多线程"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"title":"多线程 SQLite with C++ 踩坑汇总"}}}