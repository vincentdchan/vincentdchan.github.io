{"componentChunkName":"component---src-templates-blog-template-js","path":"/2017/05/writing-a-ray-tracing-renderer","result":{"data":{"markdownRemark":{"html":"<p>最近都在做一件事情，做一个光线追踪渲染器，一直很想揭开光线追踪渲染器的大门，于是跟着 Milo Yip 的步伐开撸了</p>\n<p><a href=\"http://www.cnblogs.com/miloyip/archive/2010/03/29/1698953.html\">用 JavaScript 玩转计算机图形学(一)光线追踪入门</a></p>\n<p>渲染结果图：\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6f3405112aa6623034871f512c1a8cd9/2bef9/renderer-img.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD9ElEQVQ4y6WT7UtbVxzH70PuQ3Ju7mOSm8QbY4yaxJhEG6tLdDWzoFU6SaNVtm60uqS6+TAE220x0+xGqlkSNWStlkrXDedgbsp0+GIwKsMXg8JgCJVSOrq92MuxP2A0u9E3hVH2Yl8OnMM5v8/v/B7OgaD/L/h4nAh5ocm/bV/g4r/OnzMyo2hYrZ6g6fc47k2aLlOpng8BRjU44wHm83rHoLl2kGQcx7vHaAWKXqWoj1h2xWK5Hwj82t39vccTIIgTHlEBnD2lkBbv8Pkr6x9+8nRo+mfecrZEEjDcSZKDAExy3Gpd3W/j48WtrWf5/H2fz4aU7kZxHqNdlNjibX17OntwcFTc+anYeXkXxgSIQ5AzOB5Rq2M0nXY4DkdGint7xZ2dx70XYxQlkIRRQ0OEEQg+h/+16OS9mxuP51YO2wbW1bogpEaQepLs0mrfEIQpq/XTUOhwdPTR+Ph268vvc2zQYKjhWBijaMEhVbU3vTLSeXGu9dWU9XScFF6CYASp5vl2ozFiNA6Vl0/a7QsNDR/7fAmp7AoAVgwTNRpe0HH6cpPVr/C2uoi17vUyzzAGKiAcx1mt1qnTeUgyxDBX3e4hqzVqsUzYbAEAgFqtVmECzwFKC6GUVNlU7e3W2c6J9i6CBNCFcLi+vl7g+Sqz2a3T+bTa0wD4cbxFFIONjY1NTaISeUWFRZJMJjMrlKk0kmRvaQq02e02KBKJjI2N9fT0OF0un9cr8jyFoq7Kys6OjnNdXcFg0OFwSJLkdrsNBgMMIyZzeXWN0yiKXq8Pikajs7Oz09PT705M9Pf36/V6pT0MywKK4gVhdHT0g3h8ZmYmm80qa8WF0SgSBA7DsMlkgpxOp+K7NxKRZTkai/X19g709fWHw5cHBsI9PX6/v7m5uT0UajvTFgqFPB4PAFTDKf/AsSCz2axMyWQyt7hYyOcLmcxKOv350tK3q6uLiYQGACUQEsMIHEdRtPTmUJLhJXddfSwWhVKpVOZY87K8JMvry8sbudxX2ex2Lnf72rUyhsERRKk6QRBKUxlWzwoSQUmwSii97EQioaS0nE7fTqc/y2S+yed/WFs7uHv3x1u3vozHq3Q6pX4ESZAkqQEMw5l5g53R1Wg4F4ppIaVaC8nkzVTq3sLCZi63f+fO0729P/f3f9/8eiMetwgCXfphsArTUIxosriqXEFrdZA2+FFShOZmZwuyvCbLX8zNfbe4+Ghz8++HD4tPnvy1vV24fl1NlXKGEQLBtICRqmoDoc5LZ7vfqvZdwEE5dCOZPCG35uf3C4U/dneLR0fPHjz4ZXV1anISlGAUxRiU0Gt5e21DR9+lqcF3bjS3D2Ma0z/9ZgK8uPxLxwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"renderer img\"\n        title=\"renderer img\"\n        src=\"/static/6f3405112aa6623034871f512c1a8cd9/8c557/renderer-img.png\"\n        srcset=\"/static/6f3405112aa6623034871f512c1a8cd9/4edbd/renderer-img.png 175w,\n/static/6f3405112aa6623034871f512c1a8cd9/13ae7/renderer-img.png 350w,\n/static/6f3405112aa6623034871f512c1a8cd9/8c557/renderer-img.png 700w,\n/static/6f3405112aa6623034871f512c1a8cd9/2bef9/renderer-img.png 1024w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>其实制作的过程是非常坎坷的，我首先用 C# 按照博文的思路重写了一边，渲染出结果（1024x1024），总共耗时6秒，结果令人很不满意，觉得有点慢，于是打算用 C++ 重新实现一遍，使用 MSVC 编译器，第一次做出来的结果是2.1s，比 C# 快一点，但是优势还不是很明显。但是我做了如下改动之后，性能得到了极大的提升：</p>\n<p>本来的写法：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>Result<span class=\"token operator\">></span> <span class=\"token function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">do_something</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> std<span class=\"token operator\">::</span>make_share<span class=\"token operator\">&lt;</span>Result<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>改为：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">function</span><span class=\"token punctuation\">(</span>Result<span class=\"token operator\">&amp;</span> result<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">do_something</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n\t<span class=\"token punctuation\">{</span>\n\t\tresult <span class=\"token operator\">=</span> xxx<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>经过这一改动之后，渲染实践从原来的 2.1 秒瞬间缩短到了 0.6s，有点令人不可思议，个人猜测是 shared_ptr 进行频繁的分配和释放空间导致的速度大幅度变慢。0.6s 的渲染时间让我觉得很满意，本来想继续做下一步实验，但是不知道怎么的，我总是觉得程序还能优化。于是我看了看 Profile，没发现什么问题，我觉得该改的都改了，再改可能也得不到大幅度的提升，后来我往另一个方面想：多线程</p>\n<p>光线追踪算法每个像素的计算之间没有任何关系，这意味着，可以同时进行计算，然后最后把结果合并，pbrt 也讲了这种思想，于是我也试试。一开始我使用了 Windows 的 API，可是我没有什么 Windows 的编程经验，Win32 的 API 都是现查现用，于是出现了一个我解决不了的问题，就是我用WaitForMultipleObjects 函数去等待子线程结束，调度线程才结束，可是每次调度线程自己先结束了，WaitForMultipleObjects 函数没起到作用，我检查了结果，在正确范围内，也没发现问题，但是就是不行，没办法解决。</p>\n<p>后来采用 boost 的 thread 框架，成功地使用了 join，调度程序等所有渲染都完成了才结束，由于我使用的电脑的 CPU 是 i5-5200U，双核四线程，所以我开了四线程，进行渲染，总共耗时 0.3s，速度可以说是加快了许多，我尝试开八线程进行渲染，也是 0.3s，速度没有得到提升，说明四线程在我的电脑上应该是最合适的。</p>\n<p>多线程的问题解决了，然后就可以进行下一步的实验了。</p>","excerpt":"最近都在做一件事情，做一个光线追踪渲染器，一直很想揭开光线追踪渲染器的大门，于是跟着 Milo Yip 的步伐开撸了 用 JavaScript 玩转计算机图形学(一)光线追踪入门 渲染结果图：\n 其实制作的过程是非常坎坷的，我首先用 C# 按照博文的思路重写了一边，渲染出结果（1024x1024），总共耗时6秒，结果…","frontmatter":{"date":"2017-05-18T00:01:00.000Z","path":null,"title":"写一个光线追踪渲染器","permalink":"writing-a-ray-tracing-renderer","headerImage":null,"tags":["renderer"]}}},"pageContext":{"title":"写一个光线追踪渲染器"}},"staticQueryHashes":["3128451518","3159585216","3649515864"]}