{"data":{"markdownRemark":{"html":"<p>Scala 中的 for 表达式非常强大，用起来很简单顺手，但是理解起来可能需要一些背景知识。这个 for 从名字上看让我们觉得它很像命令式语言中的那种 for statement，但是其实 Scala 的 for 是非常函数式的，它跟命令式语言中的 for 语句根本不是一个东西，因为它根本不支持 break 和 continue 这些语句。</p>\n<p>官方文档提供的例子：</p>\n<pre><code class=\"language-scala\">val twentySomethings = for (user &#x3C;- userBase if (user.age >=20 &#x26;&#x26; user.age &#x3C; 30))\n  yield user.name  // i.e. add this to a list\n</code></pre>\n<p>Scala 的 for 表达式倒是很像 Python 和 Haskell 里面的 list comprehension，其实这个 for 表达式基本上可以等同于 Haskell 的 list comprehension 加上 do annotation 了。然而 Haskell 里面 list comprehension 和 do 也是一个东西，所以基本等同于 for comprehension。</p>\n<p>在理解 for 之前，需要先了解 <code>map</code> 和 <code>flatMap</code>，这些概念在 Scala 和 Haskell 中很相似：</p>\n<h2>Map</h2>\n<p><code>map</code> 大多数人会用在 List 上面，但是更广义的概念上，map 可以用在任何带有 context 的类型上面，不仅限于 List：</p>\n<pre><code>// map 通过一个函数，可以把 A 元素的列表转换成列表 B 的\nmap(f: A => B): List[A] => List[B]\n</code></pre>\n<p>同理，map 不仅可以用在 <code>List</code> 上面，也可以用在类似 Option 和 Future 这样的类型上面。从直观意义上理解，map 同样可以把 <code>Option[A]</code> 转换成 <code>Option[B]</code>，把 <code>Future[A]</code> 转换成 <code>Future[B]</code>。</p>\n<p>在 Hasekll 里面，这种支持 map 操作的类型，叫做 Functor，Scala 里面似乎没有一个名字。</p>\n<h2>FlatMap</h2>\n<p><code>flatMap</code> 理解起来则稍微复杂一些，看一下 List 里面的 <code>flatMap</code>:</p>\n<pre><code class=\"language-scala\">def flatMap[U](f: T => List[U]): List[U]\n</code></pre>\n<p>这里面的 <code>f</code> 不再像 <code>map</code> 里面返回一个新的子类型，而是，返回一个带有 context 类型本身： <code>List[U]</code>。也就是说 f 函数返回的新类型是包含在 context 里面的。<strong>需要注意的是</strong>在这里，返回的结果并不是 List[List[U]]，而是仅仅是 <code>List[U]</code> 。通过 <code>flatMap</code> 这个名字中的 <code>flat</code> 我们也知道，最后的结果会是把每个 list 都拼接在一起，也就是所谓的拍平了。</p>\n<p>上面提到的是 List 的 flatMap，同样地，<code>Future</code> 类型同样也是支持 <code>flatMap</code> 的，它的的参数 <code>f</code> 类型我们应该也猜到了：</p>\n<pre><code class=\"language-scala\">def flatMap[U](f: T => Future[U]): Future[U]\n</code></pre>\n<p>通过 flatMap 我们就可以做很多事情了。这个时候假设我们有函数 <code>fetch1</code> 和 <code>fetch2</code> ，都是返回 <code>Future[Response]</code>，如果我们要先 fetch1 然后根据 1 的 response 来 fetch2 ，然后把 2 的结果打印出来，我们要怎么做呢：</p>\n<pre><code class=\"language-scala\">// 写法一\nval resp2 = fetch1\n.flatMap { resp1 =>\n    // do something\n    fetch2(resp1.data) // 通过 1 的结果来返回新的 Future\n}\n.map { resp2 =>\n    printf(resp2.data)\n    resp2.data\n}\n</code></pre>\n<p>然后回到开头，我们可以用 for comprehension 来完成这个事情：</p>\n<pre><code class=\"language-scala\">// 写法二\nval resp2 = for {\n    resp1 &#x3C;- fetch1()\n    resp2 &#x3C;- fetch2(resp1.data)\n    printf(resp2.data)\n} yield resp2.data\n</code></pre>\n<p>其实实际上，Scala 会把上述代码翻译成与下面等价的样子：</p>\n<pre><code class=\"language-scala\">// 写法三\nval resp2 = resp1\n.flatMap { resp1 =>\n    fetch2(resp2.data)\n    .map {\n        printf(resp2.data)\n        resp2.data\n    }\n}\n</code></pre>\n<p>只要你仔细观察，你就会发现，在这个例子里面，这三种写法的结果都是一样的，但是第一种写法有什么缺点呢，缺点就是在第二个 <code>flatMap</code> 里面，<code>resp1</code> 已经不在作用域里面了，这个时候如果你还想调用 resp1 已经不可能了，但是写法三是可以的：</p>\n<pre><code class=\"language-scala\">// 写法三\nval resp2 = resp1\n.flatMap { resp1 =>\n    fetch2(resp2.data)\n    .map {\n        printf(resp1.data) // 在这里仍然可以调用 resp1，因为它还在作用域里面\n        printf(resp2.data)\n        resp2.data\n    }\n}\n</code></pre>\n<p>这样看起来就跟 Haskell 的 Monad 很接近了。</p>\n<h2>For 表达式的几种翻译方式</h2>\n<p>其实明白了 map 和 flatMap 之后，for 表达式很容易理解了。但是实现起来还要参考 <a href=\"https://docs.scala-lang.org/tutorials/FAQ/yield.html\">for 表达式的翻译方式</a>。</p>\n<h3>If</h3>\n<p>值得注意的是 if 语法：</p>\n<pre><code class=\"language-scala\">for(x &#x3C;- c; if cond) yield {...}\n</code></pre>\n<p>会被翻译成：</p>\n<pre><code class=\"language-scala\">c.withFilter(x => cond).map(x => {...})\n</code></pre>\n<p>当然会有 fallback （如果不支持 withFilter）：</p>\n<pre><code class=\"language-scala\">c.filter(x => cond).map(x => {...})\n</code></pre>\n<p>这时候再看文章开头的例子：</p>\n<pre><code class=\"language-scala\">val twentySomethings = for (user &#x3C;- userBase if (user.age >=20 &#x26;&#x26; user.age &#x3C; 30))\n  yield user.name  // i.e. add this to a list\n</code></pre>\n<p>会被翻译成：</p>\n<pre><code class=\"language-scala\">val twentySomethings = userBase\n.filter { user =>\n    user.age >=20 &#x26;&#x26; user.age &#x3C; 30\n}\n.map { _.name }\n</code></pre>\n<p>就很容易理解了</p>\n<h3>赋值语句</h3>\n<p><code>for</code> 表达式中同样支持赋值语句（这里说的是 <code>=</code> 不是 <code>&#x3C;-</code>），这在处理异步请求的时候非常常见：</p>\n<pre><code class=\"language-scala\">val resp2 = for {\n    resp1 &#x3C;- fetch1()\n    data = doSomething(resp1)\n    resp2 &#x3C;- fetch2(data)\n    printf(resp2.data)\n} yield resp2.data\n</code></pre>\n<p>注意，在 for comprehension 中写 <code>=</code> 赋值语句并不需要写 <code>var</code> 或者 <code>val</code> ，至于为什么，只要看它会被翻译成什么样子就能明白：</p>\n<pre><code class=\"language-scala\">val resp2 = for {\n    resp1 &#x3C;- fetch1()\n    data = doSomething(resp1)\n    resp2 &#x3C;- fetch2(data)\n    printf(resp2.data)\n} yield resp2.data\n\nvar resp2 = fetch1()\n.map { resp1 =>\n    (resp1, doSomething(resp1))\n}\n.flatMap { \n    case (resp1, data) =>\n        fetch2(data)\n    .map { resp2 =>\n        printf(resp2.data)\n        resp2.data\n    }\n}\n</code></pre>\n<p>所以这个时候再写 <code>val</code> 和 <code>var</code> 已经没什么意义了</p>\n<h2>CPS 变换</h2>\n<p>其实 Scala 做的这个变换是一种 CPS(Continuation Passing Style) 变换，把一系列看上去想是赋值 <code>&#x3C;-</code> 的操作转换成 CPS 的形式，这有什么好处呢，通过这种变换，map 和 flatMap 的参数 f 就可以是一个纯（Pure）的函数，也就是说通过一系列纯函数的组合，可以实现像命令式编程里面的有状态的赋值操作，而这些操作是含有上下文（context）的。</p>\n<p>另一个好处是，像下面这种调用：</p>\n<pre><code class=\"language-scala\">c1.map(p1 => p1.map(p2 => p2.map(p3 => ...)))\n</code></pre>\n<p>其实是尾递归调用，编译器可以为此做很多优化，提高运行速度。</p>\n<h1>总结</h1>\n<p>for comprehension 其实是一个很甜很好用的语法糖，可以帮我们省下很多代码。我们当然可以选择继续用 <code>flatMap</code> 和 <code>map</code>，但是 for 就能用很简单的语言写出来。当然，简单的背后是有代价的，用 for 的过程中就需要使用者明白表达式最终会被怎样转换成相应的 <code>flatMap</code> 和 <code>map</code> 代码，这样才能让我们写出简洁的 for comprehension。</p>\n<p>这个时候，我真的很佩服 Scala 的设计，让整个语言各个部分的设计都非常容易和优雅地组合，设计得相当地精妙，同时我在其中也看到了一些 Haskell 的味道。</p>","frontmatter":{"date":"2018-06-10T02:58:33.000Z","path":null,"title":"理解 Scala 中的 for 表达式","permalink":"understanding-for-comprehansion-in-scala","headerImage":null}},"headerImage":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAT/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFOEQP/xAAZEAABBQAAAAAAAAAAAAAAAAABAAIDETL/2gAIAQEAAQUCoCB+F//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABEQ/9oACAEBAAY/Akv/xAAZEAEAAwEBAAAAAAAAAAAAAAABABExUYH/2gAIAQEAAT8hqKF2LfsF7P/aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEAAwEBAAAAAAAAAAAAAAABABExUUH/2gAIAQEAAT8QLSDT0aiKQZQ55AWC3s//2Q==","tracedSVG":"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='400' height='84' viewBox='0 0 400 84' version='1'%3e%3cpath d='M0 42v42h18v-6c1-4 1-6 3-8l3-3 2-5c2-3 2-6 2-14 0-10 0-10 3-13l2-3c1-1 11-12 15-14l5-2 3-1 1-2 3-2c1-2 3-3 5-3 1 0 5-5 5-8H0v42M91 2c0 2 5 4 6 3l1 3 1 4h5l2-3 3-3h1l1-2c-1-1 0-2 1-3s0-1-10-1-11 0-11 2m32 0c0 2 0 2-2 2l-4 2c-2 2-2 2-1 3l2 2 1 2c2 0 3 3 2 3l-3-3c-2-3-4-4-6-1-2 1-2 2-1 4v3c-5 0-4 6 1 7l10 7v2c0 2 5 3 8 1 5-2 5 0 0 3-6 3-7 5-6 8l-1 5v2c3 0 4-1 4-3l1-4c1-1 1-1 1 2-1 4-1 4 6-3 6-6 6-6 0-11-1-1 0-2 4-6 3-5 4-6 3-8l-1-2c-2 1-4 0-4-3-1-3-1-3-2-2s-1 1-2-1c-3-3-3-6 0-4 1 1 1 1 1-1 0-3-3-9-3-7-1 2-7 2-7 0-1-1-1-1-1 1m26 0c2 3 3 4 4 2 1-1 1-1 3 1l4 3 1 2 1 4v3l-1 3-1 2-2-1c1-3 0-5-2-5-3 0-16 14-14 15 2 2 9 2 11 0s2-2 3-1c1 2 2 1 2-1v-3h7l2 1 1-1v-6c-1-2 0-5 2-4l1-1c0-3 2-2 2 0l2 3 1 4 2 2c1 0 2-1 2-4l1-4c3 0 2-2-1-5-2-2-4-4-3-5 0-1-5-2-7-1l-2 3c1 1 0 1-1 1l-2-1c0-5-12-11-12-6h-2c-2-3-3-2-2 0m93 1l3 5 3 23c0 3 0 4 3 3 3 0 3 0 3-5l-1-5c-2 0-4-4-3-6 1-1 0-2-1-3l-1-9V0h-8l2 3m17-1l2 6v22c1 9 3 11 7 14l4 3 5 1c4 0 5 0 4 2l2 5c2 2 2 8-2 14v3l-2 2c-2 2-2 2 0 3 2 0 6 5 6 6l58 1h57V0h-13c-13 0-13 0-13 2l-1 3V2l-1-2h-39c-37 0-38 0-40 2-2 3-4 3-5 0 0-3-29-3-29 0m29 5l-3 1c-2 0-2 0-2 5 0 4 1 4 3 4l2 1 1 1 1-1 2-3c2-2 3-6 0-8-2-2-3-2-4 0m-79 7c-3 3-2 5 1 6 5 0 8 4 7 9l-1 4v-5l-1-4v1c1 2-2 7-5 7-2 0-6 6-5 9l-1 4c-1 1-1 1-2-1-1-3-4-4-8-4l-4-1-2-1 1 2v1c-3 1-2 3 0 4h2a424 424 0 0 0 4 8c0 2 8 8 10 8l3 1c1 1 6 0 7-2l-2-3c-8-2-11-4-10-6v-3l2 2 7 3 6 2c1 2 1 2 4-4l2-4-3-3c-2-2-3-3-2-5 0-5 3-12 4-12l1-1-1-2-1-3c2-7 0-9-5-10-4 0-6 1-8 3m-17 51c1 11 1 13-1 14-1 0-2 0-2-2l-2-3-2-3c-1-2-2-2-4-2l-7 5-12 3-19-7c-7-3-9-3-10-2 0 2-1 2-5 0-4-1-4-1-6 1-1 1-2 3-4 3-2 1-2 1 3 3 7 2 12 5 12 7 0 1 3 2 24 2 23 0 24 0 23-2 0-3 4-3 5 0l1 2 1-2 1-2 1 2c0 2 1 2 5 2s5-1 9-8c1-2-2-4-5-4-3 1-3 1 0-3 1-1 2-3 1-4l-3-1-3-3-2-2 1 6m64 2l-2 1-2 4c-2 1-3 3-2 4v3l2 1 4 2c1 2 7 3 8 1v-3c-2-2-2-5-1-5 2 0 1-6 0-8h-7' fill='lightgray' fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":4.751219512195122,"src":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/8484e/new-worlds.jpg","srcSet":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/6ad16/new-worlds.jpg 200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/8f1ca/new-worlds.jpg 400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/8484e/new-worlds.jpg 800w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/150f3/new-worlds.jpg 1200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/bea14/new-worlds.jpg 1600w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/67033/new-worlds.jpg 2400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/96ae4/new-worlds.jpg 4870w","srcWebp":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/765ea/new-worlds.webp","srcSetWebp":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/05ec5/new-worlds.webp 200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/8cb0a/new-worlds.webp 400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/765ea/new-worlds.webp 800w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/dd093/new-worlds.webp 1200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/ccbd9/new-worlds.webp 1600w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/db648/new-worlds.webp 2400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/1ac8a/new-worlds.webp 4870w","sizes":"(max-width: 800px) 100vw, 800px","originalImg":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/96ae4/new-worlds.jpg","originalName":"new-worlds.jpg","presentationWidth":800,"presentationHeight":168}}}},"pageContext":{"title":"理解 Scala 中的 for 表达式"}}