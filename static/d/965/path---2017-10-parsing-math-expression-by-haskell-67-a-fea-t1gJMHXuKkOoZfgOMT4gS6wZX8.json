{"data":{"markdownRemark":{"html":"<p>最近在学习 Haskell，不得不说，这真的是一门令我着迷的语言，lazy 和纯函数式等特性都非常吸引我，不过短时间内还无法掌握得很好，最重要是思维的转变非常苦难。</p>\n<p>学习一门语言最好的办法就是多实践，我还记得我写过一片文章<a href=\"https://vincentdchan.github.io/2016/07/parse-math-expression/\">编译原理学习笔记1：解析数学表达式</a>\n来讲述怎样去解析数学表达式，但是我没有讲如何去实现，现在刚好用 Haskell 实现一个。</p>\n<p>本篇文章所有源码<a href=\"https://gist.github.com/vincentdchan/78435adcbb007df77e0c674201202925\">https://gist.github.com/vincentdchan/78435adcbb007df77e0c674201202925</a></p>\n<p>gists 里包含了我曾经在我的作业里面用 C# 实现了一个过程式的数学表达式运算器，总代码 161 行，而 Haskell 版只用了54行。FP 的 pattern matching 在写状态复杂的程序的时候真的如虎添翼。</p>\n<h2>写一个词法分析器 Tokenizer</h2>\n<p>我们要把字符串解析成一个个 token，也就是我们平时所说的词法分析器里面的”词“，想想一个数学表达式里面有什么类型的 token？大概是只有数学符号和是数字？</p>\n<pre><code class=\"language-haskell\">data Token = Num Int \n    | T_Plus | T_Sub \n    | T_Mul | T_Div\n    deriving (Show)\n</code></pre>\n<p>注意我在上一篇博文里面提到的优先级问题，我们需要有一个函数来返回操作符的优先级，我们可以用 pattern matching</p>\n<pre><code class=\"language-haskell\">getPrecedence:: Token -> Int\ngetPrecedence T_Plus = 1\ngetPrecedence T_Sub = 1\ngetPrecedence T_Mul = 2\ngetPrecedence T_Div = 2\n</code></pre>\n<p>这种表达可以说是非常优雅了，然后开始写一个词法分析器……的定义</p>\n<pre><code class=\"language-haskell\">tokenizer:: String -> [Token]\n</code></pre>\n<p>Haskell 的类型定义，一个词法分析器输入一个字符串，然后输出一串 Token</p>\n<p><strong>接下来看我放大招</strong></p>\n<p><code>tokenizer</code> 函数将调用下面这个稍微复杂一点的 <code>_tokenizer</code> 来完成词法分析操作，下面我来解释一下这个函数的参数有什么作用</p>\n<ol>\n<li>第一个参数就是待解析的字符串</li>\n<li>第二个参数是暂存的数据缓冲区，如果我们要读入数字1234，那么要先把123先缓存起来，读入4后再一起解析</li>\n<li>第三个参数是<strong>之前已经读入的token</strong>, 我们把这次解析出来的token连接进去，然后通过递归传给下一次运算，最后直接返回下一次的递归调用返回的值，这种写法叫做尾递归，可以减少内存的使用。关于尾递归这里不详细说。</li>\n</ol>\n<pre><code class=\"language-haskell\">_tokenizer:: String -> String -> [Token] -> [Token] -- 尾递归写法\n_tokenizer \"\" [] previous = previous -- 所有字符都解析完毕\n_tokenizer \"\" buf previous = ((Num $ read $ reverse buf):previous) -- 字符都解析完毕，但是缓冲区还有数据\n_tokenizer (ch:expr) buf previous = \n    if (Data.Char.isDigit ch) then -- 当前字符是一个数字\n        _tokenizer expr (ch:buf) previous -- 把数字放入缓冲区\n    else -- 当前字符不是数字\n        case buf of  -- 检查缓冲区是否为空\n            [] ->  -- 缓冲区为空\n                case ch of -- 解析当前字符\n                    '+' -> _tokenizer expr [] (T_Plus:previous)\n                    '-' -> _tokenizer expr [] (T_Sub:previous)\n                    '*' -> _tokenizer expr [] (T_Mul:previous)\n                    '/' -> _tokenizer expr [] (T_Div:previous)\n            _ -> _tokenizer (ch:expr) [] ((Num $ read $ reverse buf):previous) -- 缓冲区不为空，读取缓冲区字符\n</code></pre>\n<p><strong>注意</strong>：缓冲区保存的数字缓冲是倒序的，当我们用 <code>read</code> 函数读取数值的时候，要先用 <code>reverse</code> 函数反转</p>\n<p>然后 <code>tokenizer</code> 的定义就很简单了，我们词法分析出来的列表是倒序的，我们要用reverse函数来反转。</p>\n<pre><code class=\"language-haskell\">tokenizer expr = reverse (_tokenizer expr [] [])\n</code></pre>\n<h2>表达式求值</h2>\n<p>到此为止，词法分析器就完成了，当我们对一串字符串调用 tokenizer 就可以得到一串 token 了，接下来就是如何对表达式进行求值，原理可以回顾<a href=\"https://vincentdchan.github.io/2016/07/parse-math-expression/\">编译原理学习笔记1：解析数学表达式</a>，这里讲讲实现</p>\n<pre><code class=\"language-haskell\">-- 定义操作符运算\nevalOp :: Token -> Int -> Int -> Int\nevalOp T_Plus a b = a + b\nevalOp T_Sub a b = a - b\nevalOp T_Mul a b = a * b\nevalOp T_Div a b = a `div` b\n\n-- 搞一个好看点的包装函数\neval :: [Token] -> Int\neval ((Num value):tokens) = _eval tokens [value] []\n\n-- 真正运作的函数在这里\n_eval :: [Token] -> [Int] -> [Token] -> Int\n-- 操作数栈里面只有一个数了，就是我们要求的值了\n_eval [] [value] _ = value\n-- 操作符栈数值为空，进行SHIFT操作\n_eval (op:(Num num):tokens) numStack [] =\n    _eval tokens (num:numStack) [op]\n-- 操作符栈不为空\n_eval (op:(Num num):tokens) numStack (topOp:opStack) =\n    if (getPrecedence op) > (getPrecedence topOp) then\n        _eval tokens (num:numStack) (op:topOp:opStack) -- SHIFT\n    else -- REDUCE\n        case numStack of\n            (num1:num2:stack) ->\n                _eval (op:(Num num):tokens) ((evalOp topOp num1 num2):stack) opStack\n-- 栈里还有一些残留的值，继续运算\n_eval [] (num1:num2:numStack) (topOp:opStack) =\n    _eval [] ((evalOp topOp num1 num2):numStack) opStack\n</code></pre>\n<p>这里 <code>_eval</code> 的参数</p>\n<ol>\n<li>要解析的 token 集合</li>\n<li>操作数的栈</li>\n<li>操作符的栈</li>\n</ol>\n<h2>总结</h2>\n<p>总的来说，在 pattern matching 的帮助下，写一个表达式求值的程序可以说非常简洁明了。当你用过程式语言去写 tokenizer 的时候，你需要控制一个指针在字符串上移来移去，非常容易出错，如果用 pattern matching，只需要定义好相应的字符串就可以了，非常优雅。</p>","frontmatter":{"date":"2017-10-30T20:26:27.000Z","path":null,"title":"初窥 Haskell：解析一个数学表达式","permalink":"parsing-math-expression-by-haskell","headerImage":null}},"headerImage":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAT/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFOEQP/xAAZEAABBQAAAAAAAAAAAAAAAAABAAIDETL/2gAIAQEAAQUCoCB+F//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABEQ/9oACAEBAAY/Akv/xAAZEAEAAwEBAAAAAAAAAAAAAAABABExUYH/2gAIAQEAAT8hqKF2LfsF7P/aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEAAwEBAAAAAAAAAAAAAAABABExUUH/2gAIAQEAAT8QLSDT0aiKQZQ55AWC3s//2Q==","tracedSVG":"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='400' height='84' viewBox='0 0 400 84' version='1'%3e%3cpath d='M0 42v42h18v-6c1-4 1-6 3-8l3-3 2-5c2-3 2-6 2-14 0-10 0-10 3-13l2-3c1-1 11-12 15-14l5-2 3-1 1-2 3-2c1-2 3-3 5-3 1 0 5-5 5-8H0v42M91 2c0 2 5 4 6 3l1 3 1 4h5l2-3 3-3h1l1-2c-1-1 0-2 1-3s0-1-10-1-11 0-11 2m32 0c0 2 0 2-2 2l-4 2c-2 2-2 2-1 3l2 2 1 2c2 0 3 3 2 3l-3-3c-2-3-4-4-6-1-2 1-2 2-1 4v3c-5 0-4 6 1 7l10 7v2c0 2 5 3 8 1 5-2 5 0 0 3-6 3-7 5-6 8l-1 5v2c3 0 4-1 4-3l1-4c1-1 1-1 1 2-1 4-1 4 6-3 6-6 6-6 0-11-1-1 0-2 4-6 3-5 4-6 3-8l-1-2c-2 1-4 0-4-3-1-3-1-3-2-2s-1 1-2-1c-3-3-3-6 0-4 1 1 1 1 1-1 0-3-3-9-3-7-1 2-7 2-7 0-1-1-1-1-1 1m26 0c2 3 3 4 4 2 1-1 1-1 3 1l4 3 1 2 1 4v3l-1 3-1 2-2-1c1-3 0-5-2-5-3 0-16 14-14 15 2 2 9 2 11 0s2-2 3-1c1 2 2 1 2-1v-3h7l2 1 1-1v-6c-1-2 0-5 2-4l1-1c0-3 2-2 2 0l2 3 1 4 2 2c1 0 2-1 2-4l1-4c3 0 2-2-1-5-2-2-4-4-3-5 0-1-5-2-7-1l-2 3c1 1 0 1-1 1l-2-1c0-5-12-11-12-6h-2c-2-3-3-2-2 0m93 1l3 5 3 23c0 3 0 4 3 3 3 0 3 0 3-5l-1-5c-2 0-4-4-3-6 1-1 0-2-1-3l-1-9V0h-8l2 3m17-1l2 6v22c1 9 3 11 7 14l4 3 5 1c4 0 5 0 4 2l2 5c2 2 2 8-2 14v3l-2 2c-2 2-2 2 0 3 2 0 6 5 6 6l58 1h57V0h-13c-13 0-13 0-13 2l-1 3V2l-1-2h-39c-37 0-38 0-40 2-2 3-4 3-5 0 0-3-29-3-29 0m29 5l-3 1c-2 0-2 0-2 5 0 4 1 4 3 4l2 1 1 1 1-1 2-3c2-2 3-6 0-8-2-2-3-2-4 0m-79 7c-3 3-2 5 1 6 5 0 8 4 7 9l-1 4v-5l-1-4v1c1 2-2 7-5 7-2 0-6 6-5 9l-1 4c-1 1-1 1-2-1-1-3-4-4-8-4l-4-1-2-1 1 2v1c-3 1-2 3 0 4h2a424 424 0 0 0 4 8c0 2 8 8 10 8l3 1c1 1 6 0 7-2l-2-3c-8-2-11-4-10-6v-3l2 2 7 3 6 2c1 2 1 2 4-4l2-4-3-3c-2-2-3-3-2-5 0-5 3-12 4-12l1-1-1-2-1-3c2-7 0-9-5-10-4 0-6 1-8 3m-17 51c1 11 1 13-1 14-1 0-2 0-2-2l-2-3-2-3c-1-2-2-2-4-2l-7 5-12 3-19-7c-7-3-9-3-10-2 0 2-1 2-5 0-4-1-4-1-6 1-1 1-2 3-4 3-2 1-2 1 3 3 7 2 12 5 12 7 0 1 3 2 24 2 23 0 24 0 23-2 0-3 4-3 5 0l1 2 1-2 1-2 1 2c0 2 1 2 5 2s5-1 9-8c1-2-2-4-5-4-3 1-3 1 0-3 1-1 2-3 1-4l-3-1-3-3-2-2 1 6m64 2l-2 1-2 4c-2 1-3 3-2 4v3l2 1 4 2c1 2 7 3 8 1v-3c-2-2-2-5-1-5 2 0 1-6 0-8h-7' fill='lightgray' fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":4.751219512195122,"src":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/8484e/new-worlds.jpg","srcSet":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/6ad16/new-worlds.jpg 200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/8f1ca/new-worlds.jpg 400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/8484e/new-worlds.jpg 800w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/150f3/new-worlds.jpg 1200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/bea14/new-worlds.jpg 1600w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/67033/new-worlds.jpg 2400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/96ae4/new-worlds.jpg 4870w","srcWebp":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/765ea/new-worlds.webp","srcSetWebp":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/05ec5/new-worlds.webp 200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/8cb0a/new-worlds.webp 400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/765ea/new-worlds.webp 800w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/dd093/new-worlds.webp 1200w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/ccbd9/new-worlds.webp 1600w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/db648/new-worlds.webp 2400w,\n/static/02c8b40bb175bb1dbcf2bd5d46593c48/1ac8a/new-worlds.webp 4870w","sizes":"(max-width: 800px) 100vw, 800px","originalImg":"/static/02c8b40bb175bb1dbcf2bd5d46593c48/96ae4/new-worlds.jpg","originalName":"new-worlds.jpg","presentationWidth":800,"presentationHeight":168}}}},"pageContext":{"title":"初窥 Haskell：解析一个数学表达式"}}