{"data":{"markdownRemark":{"html":"<h1>起因</h1>\n<p>最近在写一个关于 JavaScript 的静态分析器，作为我的毕业设计。我写静态分析主要是为了 js 做更好的 DCE(Dead Code Elimination)，做更多关于 ES6 层面的优化。</p>\n<h1>为什么选择 OCaml</h1>\n<p>在和导师讨论题目的时候，我跟导师说用 Java 来写，但是其实我更想用的是 Scala，原因是：</p>\n<ul>\n<li>Scala 里面的很多语言特性非常有 FP 风格，也很适合用来写编译器和静态分析工具。</li>\n<li>运行在 JVM 上面更容易做多线程，有了多线程可以使静态分析过程有较大的提升。</li>\n<li>如果有需要，Scala 可以编译成 js，或者 JVM 上面有很多可以和 js 联动的方案，方便和其他 node.js 的工具联动。</li>\n</ul>\n<p>但是开始使用 Scala 的时候却发现了许多问题：</p>\n<ul>\n<li>我使用的 Parser 和 AST 结构都是 Java 写的（使用了 Graal.js 来进行 parse），无法使用 Scala 的 case class 风格，也就是我要在 Scala 里面写 Java Style 的代码，我表示很拒绝。除非写一层转换成，把 java class implicit 转换成 case class，但是我觉得这样很蛋疼，所以放弃。</li>\n<li>我要进行的静态分析是基于图（Graph）的，似乎没办法进行并行计算，即使可以，也会有超级多 overhead，还不如使用单线程。</li>\n</ul>\n<p>之前用过 OCaml 来写过编译器，感觉代数形式的数据结构天生对编译器和静态分析非常友好。而且有两个项目非常启发到我：</p>\n<ul>\n<li><strong><a href=\"https://flow.org/\">flow</a></strong>：静态分析工具，但是已经演化到类似 TypeScript 那样，变成一门语言了。我个人用过 flow，但是感觉非常慢，比 TypeScript 慢很多，但是我觉得不是 OCaml 慢，而是 flow 本身设计的问题。设计 TypeScript 的 Ander 毕竟是编译器领域的大牛，很多坑都踩过，像 TypeScript 和 VSCode 联动体验这么好肯定是经过优良设计的。</li>\n<li><strong><a href=\"https://bucklescript.github.io\">BuckleScript</a></strong>：把 OCaml 编译到 JS 的编译器（其实也算一门语言？）。作者号称编译速度最快的语言，编译速度比 TypeScript 还快，并附上了 benchmark。这点也可以理解。毕竟 OCaml 这门语言比 TypeScript 简单太多了。但是这也让我看到了一线生机，OCaml 写出来的编译器也可以很快啊。</li>\n</ul>\n<p>现在 OCaml 依然没有办法实现真正意义上的多线程（有 thread，但是却有 GIL），但是这不是痛点。但是 OCaml 的冷启动速度却可以秒杀 Scala。想象一下编译几个文件的项目，Scala 还要等 JVM 预热，其实很蛋疼才能达到峰值，其实很蛋疼。</p>\n<h1>flow</h1>\n<p><strong>Github:</strong> <a href=\"https://github.com/facebook/flow\">https://github.com/facebook/flow</a></p>\n<p>flow 是利器。我写一个 JS 的静态分析工具，肯定是不可能从 parser 开始写的，现在 ES 的标准我感觉已经看不完了，我肯定是使用已有的 JS Parser。很幸运 flow 就提供了这么一个工具。flow 的代码结构还是蛮清晰，我一看项目目录基本了解各个模块的作用，而 parser 的部分则抽离出来：<a href=\"https://github.com/facebook/flow/tree/master/src/parser\">Parser</a></p>\n<p>AST 定义：<a href=\"https://github.com/facebook/flow/blob/master/src/parser/flow_ast.ml\">https://github.com/facebook/flow/blob/master/src/parser/flow_ast.ml</a></p>\n<p>flow 的 AST 都写在一个文件里面，我们看 program 的定义：</p>\n<pre><code class=\"language-ocaml\">type ('M, 'T) program = 'M * ('M, 'T) Statement.t list * 'M Comment.t list [@@deriving show]\n</code></pre>\n<p>一个 program 就是 <code>Statment.t</code> 的 list。这里我们会看到有两个泛型参数 <code>'M</code> 和 <code>'T</code>，这两个范型参数充值着整个 AST，但是它的作用很巧妙，并不是那么直观。实际上 parser 输出的结果中，<code>'M</code> 和 <code>'T</code> 都是 <code>Loc.t</code>，就是 AST 的位置信息，那么为什么需要两个范型呢？我们只要看 <code>Statement</code> 和 <code>Expression</code> 两个地方的定义就明白了：</p>\n<p><strong>Statement</strong></p>\n<pre><code class=\"language-ocaml\">  and ('M, 'T) t = 'M * ('M, 'T) t'\n  and ('M, 'T) t' =\n    | Block of ('M, 'T) Block.t\n    | Break of 'M Break.t\n    | ClassDeclaration of ('M, 'T) Class.t\n    | Continue of 'M Continue.t\n    | Debugger\n    | DeclareClass of ('M, 'T) DeclareClass.t\n    | DeclareExportDeclaration of ('M, 'T) DeclareExportDeclaration.t\n    | DeclareFunction of ('M, 'T) DeclareFunction.t\n    | DeclareInterface of ('M, 'T) Interface.t\n    | DeclareModule of ('M, 'T) DeclareModule.t\n    | DeclareModuleExports of ('M, 'T) Type.annotation\n    | DeclareTypeAlias of ('M, 'T) TypeAlias.t\n    | DeclareOpaqueType of ('M, 'T) OpaqueType.t\n    | DeclareVariable of ('M, 'T) DeclareVariable.t\n    | DoWhile of ('M, 'T) DoWhile.t\n    | Empty\n    | ExportDefaultDeclaration of ('M, 'T) ExportDefaultDeclaration.t\n    | ExportNamedDeclaration of ('M, 'T) ExportNamedDeclaration.t\n    | Expression of ('M, 'T) Expression.t\n    | For of ('M, 'T) For.t\n    | ForIn of ('M, 'T) ForIn.t\n    | ForOf of ('M, 'T) ForOf.t\n    | FunctionDeclaration of ('M, 'T) Function.t\n    | If of ('M, 'T) If.t\n    | ImportDeclaration of ('M, 'T) ImportDeclaration.t\n    | InterfaceDeclaration of ('M, 'T) Interface.t\n    | Labeled of ('M, 'T) Labeled.t\n    | Return of ('M, 'T) Return.t\n    | Switch of ('M, 'T) Switch.t\n    | Throw of ('M, 'T) Throw.t\n    | Try of ('M, 'T) Try.t\n    | TypeAlias of ('M, 'T) TypeAlias.t\n    | OpaqueType of ('M, 'T) OpaqueType.t\n    | VariableDeclaration of ('M, 'T) VariableDeclaration.t\n    | While of ('M, 'T) While.t\n    | With of ('M, 'T) With.t\n</code></pre>\n<p><strong>Expression</strong></p>\n<pre><code class=\"language-ocaml\">  type ('M, 'T) t = 'T * ('M, 'T) t'\n  and ('M, 'T) t' =\n    | Array of ('M, 'T) Array.t\n    | ArrowFunction of ('M, 'T) Function.t\n    | Assignment of ('M, 'T) Assignment.t\n    | Binary of ('M, 'T) Binary.t\n    | Call of ('M, 'T) Call.t\n    | Class of ('M, 'T) Class.t\n    | Comprehension of ('M, 'T) Comprehension.t\n    | Conditional of ('M, 'T) Conditional.t\n    | Function of ('M, 'T) Function.t\n    | Generator of ('M, 'T) Generator.t\n    | Identifier of 'T Identifier.t\n    | Import of ('M, 'T) t\n    | JSXElement of ('M, 'T) JSX.element\n    | JSXFragment of ('M, 'T) JSX.fragment\n    | Literal of Literal.t\n    | Logical of ('M, 'T) Logical.t\n    | Member of ('M, 'T) Member.t\n    | MetaProperty of 'M MetaProperty.t\n    | New of ('M, 'T) New.t\n    | Object of ('M, 'T) Object.t\n    | OptionalCall of ('M, 'T) OptionalCall.t\n    | OptionalMember of ('M, 'T) OptionalMember.t\n    | Sequence of ('M, 'T) Sequence.t\n    | Super\n    | TaggedTemplate of ('M, 'T) TaggedTemplate.t\n    | TemplateLiteral of ('M, 'T) TemplateLiteral.t\n    | This\n    | TypeCast of ('M, 'T) TypeCast.t\n    | Unary of ('M, 'T) Unary.t\n    | Update of ('M, 'T) Update.t\n    | Yield of ('M, 'T) Yield.t\n</code></pre>\n<p>也就是说，所有的 Expression 结点都会附上一个 <code>'T</code> 信息，所有的 Statement 都会附上一个 <code>'M</code> 信息。这就很容易理解了。所以这两个范型是用来区分 Statement 和 Expression 的。在 flow 里面进行 type infer 和 type check 的时候，实际上 <code>'T</code> 会是 <code>(Loc.t * Type.t)</code>。</p>","frontmatter":{"date":"2019-02-20","path":"/2019/02/parse-javascript-with-ocaml","title":"使用 OCaml 解析 JavaScript","permalink":null,"headerImage":null}}},"pageContext":{"title":"使用 OCaml 解析 JavaScript"}}