{"data":{"markdownRemark":{"html":"<h1>起因</h1>\n<p>最近在写一个关于 JavaScript 的静态分析器，作为我的毕业设计。我写静态分析主要是为了 js 做更好的 DCE(Dead Code Elimination)，做更多关于 ES6 层面的优化。</p>\n<h1>为什么选择 OCaml</h1>\n<p>在和导师讨论题目的时候，我跟导师说用 Java 来写，但是其实我更想用的是 Scala，原因是：</p>\n<ul>\n<li>Scala 里面的很多语言特性非常有 FP 风格，也很适合用来写编译器和静态分析工具。</li>\n<li>运行在 JVM 上面更容易做多线程，有了多线程可以使静态分析过程有较大的提升。</li>\n<li>如果有需要，Scala 可以编译成 js，或者 JVM 上面有很多可以和 js 联动的方案，方便和其他 node.js 的工具联动。</li>\n</ul>\n<p>但是开始使用 Scala 的时候却发现了许多问题：</p>\n<ul>\n<li>我使用的 Parser 和 AST 结构都是 Java 写的（使用了 Graal.js 来进行 parse），无法使用 Scala 的 case class 风格，也就是我要在 Scala 里面写 Java Style 的代码，我表示很拒绝。除非写一层转换成，把 java class implicit 转换成 case class，但是我觉得这样很蛋疼，所以放弃。</li>\n<li>我要进行的静态分析是基于图（Graph）的，似乎没办法进行并行计算，即使可以，也会有超级多 overhead，还不如使用单线程。</li>\n</ul>\n<p>之前用过 OCaml 来写过编译器，感觉代数形式的数据结构天生对编译器和静态分析非常友好。而且有两个项目非常启发到我：</p>\n<ul>\n<li><strong><a href=\"https://flow.org/\">Flow</a></strong>：静态分析工具，但是已经演化到类似 TypeScript 那样，变成一门语言了。我个人用过 flow，但是感觉非常慢，比 TypeScript 慢很多，但是我觉得不是 OCaml 慢，而是 flow 本身设计的问题。设计 TypeScript 的 Ander 毕竟是编译器领域的大牛，很多坑都踩过，像 TypeScript 和 VSCode 联动体验这么好肯定是经过优良设计的。</li>\n<li><strong><a href=\"https://bucklescript.github.io\">BuckleScript</a></strong>：把 OCaml 编译到 JS 的编译器（其实也算一门语言？）。作者号称编译速度最快的语言，编译速度比 TypeScript 还快，并附上了 benchmark。这点也可以理解。毕竟 OCaml 这门语言比 TypeScript 简单太多了。但是这也让我看到了一线生机，OCaml 写出来的编译器也可以很快啊。</li>\n</ul>\n<p>现在 OCaml 依然没有办法实现真正意义上的多线程（有 thread，但是却有 GIL），但是这不是痛点。但是 OCaml 的冷启动速度却可以秒杀 Scala。想象一下编译几个文件的项目，Scala 还要等 JVM 预热，其实很蛋疼才能达到峰值，其实很蛋疼。</p>\n<h1>flow</h1>\n<p><strong>Github:</strong> <a href=\"https://github.com/facebook/flow\">https://github.com/facebook/flow</a></p>\n<p>flow 是利器。我写一个 JS 的静态分析工具，肯定是不可能从 parser 开始写的，现在 ES 的标准我感觉已经看不完了，我肯定是使用已有的 JS Parser。很幸运 flow 就提供了这么一个工具。flow 的代码结构还是蛮清晰，我一看项目目录基本了解各个模块的作用，而 parser 的部分则抽离出来：<a href=\"https://github.com/facebook/flow/tree/master/src/parser\">Parser</a></p>\n<p>AST 定义：<a href=\"https://github.com/facebook/flow/blob/master/src/parser/flow_ast.ml\">https://github.com/facebook/flow/blob/master/src/parser/flow_ast.ml</a></p>\n<p>flow 的 AST 都写在一个文件里面，我们看 program 的定义：</p>\n<pre><code class=\"language-ocaml\">type ('M, 'T) program = 'M * ('M, 'T) Statement.t list * 'M Comment.t list [@@deriving show]\n</code></pre>\n<p>一个 program 就是 <code>list of Statment.t</code>。有两个泛型参数 <code>'M</code> 和 <code>'T</code> 充斥着整个 AST，虽然它的作用很巧妙，但是却并不是那么直观。实际上 parser 输出的结果中，<code>'M</code> 和 <code>'T</code> 都是 <code>Loc.t</code>，就是 AST 的位置信息，那么为什么需要两个范型呢？我们只要看 <code>Statement</code> 和 <code>Expression</code> 两个地方的定义就明白了：</p>\n<p><strong>Statement</strong></p>\n<pre><code class=\"language-ocaml\">  and ('M, 'T) t = 'M * ('M, 'T) t'\n  and ('M, 'T) t' =\n    | Block of ('M, 'T) Block.t\n    | Break of 'M Break.t\n    | ClassDeclaration of ('M, 'T) Class.t\n    | Continue of 'M Continue.t\n    | Debugger\n    | DeclareClass of ('M, 'T) DeclareClass.t\n    | DeclareExportDeclaration of ('M, 'T) DeclareExportDeclaration.t\n    | DeclareFunction of ('M, 'T) DeclareFunction.t\n    | DeclareInterface of ('M, 'T) Interface.t\n    | DeclareModule of ('M, 'T) DeclareModule.t\n    | DeclareModuleExports of ('M, 'T) Type.annotation\n    | DeclareTypeAlias of ('M, 'T) TypeAlias.t\n    | DeclareOpaqueType of ('M, 'T) OpaqueType.t\n    | DeclareVariable of ('M, 'T) DeclareVariable.t\n    | DoWhile of ('M, 'T) DoWhile.t\n    | Empty\n    | ExportDefaultDeclaration of ('M, 'T) ExportDefaultDeclaration.t\n    | ExportNamedDeclaration of ('M, 'T) ExportNamedDeclaration.t\n    | Expression of ('M, 'T) Expression.t\n    | For of ('M, 'T) For.t\n    | ForIn of ('M, 'T) ForIn.t\n    | ForOf of ('M, 'T) ForOf.t\n    | FunctionDeclaration of ('M, 'T) Function.t\n    | If of ('M, 'T) If.t\n    | ImportDeclaration of ('M, 'T) ImportDeclaration.t\n    | InterfaceDeclaration of ('M, 'T) Interface.t\n    | Labeled of ('M, 'T) Labeled.t\n    | Return of ('M, 'T) Return.t\n    | Switch of ('M, 'T) Switch.t\n    | Throw of ('M, 'T) Throw.t\n    | Try of ('M, 'T) Try.t\n    | TypeAlias of ('M, 'T) TypeAlias.t\n    | OpaqueType of ('M, 'T) OpaqueType.t\n    | VariableDeclaration of ('M, 'T) VariableDeclaration.t\n    | While of ('M, 'T) While.t\n    | With of ('M, 'T) With.t\n</code></pre>\n<p><strong>Expression</strong></p>\n<pre><code class=\"language-ocaml\">  type ('M, 'T) t = 'T * ('M, 'T) t'\n  and ('M, 'T) t' =\n    | Array of ('M, 'T) Array.t\n    | ArrowFunction of ('M, 'T) Function.t\n    | Assignment of ('M, 'T) Assignment.t\n    | Binary of ('M, 'T) Binary.t\n    | Call of ('M, 'T) Call.t\n    | Class of ('M, 'T) Class.t\n    | Comprehension of ('M, 'T) Comprehension.t\n    | Conditional of ('M, 'T) Conditional.t\n    | Function of ('M, 'T) Function.t\n    | Generator of ('M, 'T) Generator.t\n    | Identifier of 'T Identifier.t\n    | Import of ('M, 'T) t\n    | JSXElement of ('M, 'T) JSX.element\n    | JSXFragment of ('M, 'T) JSX.fragment\n    | Literal of Literal.t\n    | Logical of ('M, 'T) Logical.t\n    | Member of ('M, 'T) Member.t\n    | MetaProperty of 'M MetaProperty.t\n    | New of ('M, 'T) New.t\n    | Object of ('M, 'T) Object.t\n    | OptionalCall of ('M, 'T) OptionalCall.t\n    | OptionalMember of ('M, 'T) OptionalMember.t\n    | Sequence of ('M, 'T) Sequence.t\n    | Super\n    | TaggedTemplate of ('M, 'T) TaggedTemplate.t\n    | TemplateLiteral of ('M, 'T) TemplateLiteral.t\n    | This\n    | TypeCast of ('M, 'T) TypeCast.t\n    | Unary of ('M, 'T) Unary.t\n    | Update of ('M, 'T) Update.t\n    | Yield of ('M, 'T) Yield.t\n</code></pre>\n<p>也就是说，所有的 Expression 结点都会附上一个 <code>'T</code> 信息，所有的 Statement 都会附上一个 <code>'M</code> 信息。这就很容易理解了。所以这两个范型是用来区分 Statement 和 Expression 的。在 flow 里面进行 type infer 和 type check 的时候，实际上 <code>'T</code> 会是 <code>(Loc.t * Type.t)</code>。这个是 type check 阶段附上的信息，而 Statement 不需要这个信息，所以它仍然是 <code>Loc.t</code>。举个例子 🌰：</p>\n<pre><code>var a = 1 + 1;\n\nvar a = ((1: 'T) + (1: 'T)): 'T\nvar a = ((1: number) + (1: number)): 'T\nvar a = ((1: number) + (1: number)): number\nvar a: number = ((1: number) + (1: number)): number\n</code></pre>\n<p>从如上过程可以推出 a 的类型是 number，这个类型信息挂在所有 expression 的 AST 的上面，而 var 语句的 node 不需要这个信息。</p>\n<h1>安装</h1>\n<p>原本 <code>flow_ast</code> 可以从 opam 安装，但是我更新了 opam 之后似乎因为一些安全策略禁止包里面的 bash 脚本执行（当时社区发生了一件事，一个包的 bash 脚本把用户的整个 ~ 目录删掉，似乎是手滑写的脚本就发布了，后来 opam 对 bash 脚本做了些限制）。所以后来我只能 clone 了 flow 的代码本地进行安装</p>\n<p>进入 <code>src/parser</code> 目录执行：</p>\n<pre><code class=\"language-bash\">$ make ocamlfind-install\n</code></pre>\n<p>即可安装成功。如果使用 ocamlbuild 编译，进入 <code>_tag</code> 文件，加上 flow<em>parser。我的 `</em>tag`:</p>\n<pre><code>true: package(ppx_deriving.show), package(flow_parser), package(core_kernel)\n&#x3C;dist>: -traverse\n</code></pre>\n<h1>使用方法</h1>\n<p>使用 <code>Flow_ast</code> 自带的 <code>pp</code> 和 <code>show</code> 方法可以把 AST 打印出来，前提是你要传入 <code>'T</code> 和 <code>'M</code> 的 pretty print 方法， 这里我把 <code>Loc.pp</code> 传进去即可：</p>\n<pre><code class=\"language-ocaml\">let ast, _ = Parser_flow.program code in\nFlow_ast.show_program Loc.pp Loc.pp ast |> print_endline;\n</code></pre>\n<p>大功告成！</p>","frontmatter":{"date":"2019-02-20","path":"/2019/02/parse-javascript-with-ocaml","title":"使用 OCaml 解析 JavaScript","permalink":null,"headerImage":null}}},"pageContext":{"title":"使用 OCaml 解析 JavaScript"}}